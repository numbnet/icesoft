Ok the way this works now is this:

Each Client represents a new Session on the server.
Each Client subclass defines some protocol that is to be carried out.
One client can represent a ping thread, a receive-updated-views + receive-updates
thread, plus a send-receive-updates thread, or they can represent only a single
ping loop, etc.

The Action threads are started by the client, and they just loop through the
actors. The Actor subclasses do the main work. They write the strings that make
up the request, and do the communication using properties and utility methods
contained in the Client.


 What's a better way to do this?

 So there's the notion of repeat count, and for a simple request, that might
 be the total number of chat messages, or pings.

 the act() method defines what the actor is to do. If you have a 3 repeat count,
  then the ActionTHread will call act on all three actors 3 times. It's not up
  to the actor to know the repeat count. 

 Actor 1
 Actor 2
 Actor 3


 That's better, gets rid of a lot of unecesary crap from the actors.

 Controller Client now exposes API for getting everything from it, and passes
 itself in. Actors CAN do special stuff, but they don't need to if they want
 to work.

 {initial_delay}
   do {repeatCount} {
      for (all actors) {
        actor.act
        {interactor delay}
      }
      {interLoop delay}
   }

 That would be entirely flexible actually.


 Friday Feb 15, 2008
 -------------------

 The only problem I'm seeing is massive duplication in the classes. That part
 I had expected. To do the slightest thing differently, we have to duplicate
 the entire client and Actor class. There's no real code reuse right now, their
 could be, but I find it understand completely what's going on in a fast moving
 way with inheritance. It's difficult to know clearly exactly who is doing what
 with whom in these cases. Planning on using a code based approach in this way
 is difficult



 Assets
 ------

 Actor  - Base interface
 ActorBase - Base class that provides basic reporting method, as well as base
             getData and getDataFull implementations
 PingActor - Actor that does Ping function
 PingErrorActor - Actor that does Ping with an error
 ReceiveUpdatesActor - Basic receive-updated-views + receive-updates loop. Needs
                       to be enhanced to truly support multiple views
 SyncTestUpdatesActor - Actor that specifically does something for the syncTest
                        application, but should be refactored to provide key
                        event handling. eg. there's nothing here specific to
                        syncTest other than field and form names, and those can
                        be extracted.
 TimezoneUpdateActor - Actor that clicks on multiple points on the screen. This
                       should be refactored to use a general purpose mouse event
                       but the
 BiddingAuctionMonitorAction - bids in the auctionMonitor application, but should
                               be refactored to use a general purpose button
                               pressing algorithm. Also, I need to expose some
                               mechanism from the receiveUpdatesActor so that update
                               information from that Actor can be shared with
                               other actors.

If I share the last update from the receiveUpdates actor amongst other Actors that
care, then I'd be able to just use that, then                           



So what then do I need to do in order to do this clusteredChat nonsense? I need to
 get the initial request. Then I need something to log in, and that's a full type
 request using the mouse. Then the simple ping+receive+updates actors will suffice.

So I want to extract as much of that as possible out. So I should extend...
You see how hard it is to extend the StandalongPingReceiveUpdatesClient, and to
know what's going on? I have to override the initSubclient method to do my stuff,
then to do the superclasses init stuff. But I can't reuse the stuff that's done
in the superclass, that's done already. So the first application URL is already
fetched. Therefore, I also can't just use a copy of the SPRUC, becuase in the constructor
it's going to try to do the same stuff as well.

This means as the functionality gets more hairy, this isn't going to work so well.
It seems so simple to do. We should be able to set up almost an ordered series of
objects that we can share. That's a good thing about the GUI, if it actually
worked.

What do I have to do? I can do the login in the client, but I'd rather create an
actor to do it. A 1-time-only actor, and I'd like to add it to the queue of actors.
That means I need to fetch the actionThread from the member variable, and add my
logon actor into that thread. Then if I want to chat, I need to add another Actor
to the thread. That gets hairy hairy hairy.


            icefacesCssUpdates=""
            focus_hidden_field=""
            ice.session=controller.getIceId()
            ice.view=controller.getViewNumber()
            rand=String.valueOf(Math.random())


            ice.submit.partial=false
            ice.event.target=mapId
            ice.event.captured=mapId
            ice.event.type=onclick
            ice.event.alt=false
            ice.event.shift=false
            ice.event.meta=false
            ice.event.x=Integer.toString(p.x)
            ice.event.y=Integer.toString(p.y)
            ice.event.left=true
            ice.event.right=false

            // Is this a name field? It also could be value.
            mapId=""

            // formId = formId. Is this just a general form submission field?
            formId=formId

            // This is the component to get focus. Clicking on the map (in this case)
            ice.focus=mapId


The click chat message. Hmmm. hard to encapsulate. I'll 

             sendMessageForm:_id25: Send      what's this?
             sendMessageForm: "" 
             sendMessageForm:_id24:  message  text field value
             ice.focus: sendMessageForm:_id25

The login request. Parameters above and beyond the base

             registrationForm:startButton = Start
             registrationForm = registrationForm
             registrationForm:participantHandle = user name
             ice.focus=registrationForm:startButton 