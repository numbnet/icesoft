

The ICEsoft java test client is a tool for doing ICEfaces client simulation. 
This tool does some things well, and some things not so well. It can be 
used in conjunction with JMeter, as each tool does certain things well. 

JMeter allows recording of complex transactions and can be used to test 
navigation through an application. It is difficult to properly simulate the 
precise dual threaded nature of blocking Ajax requests, and it's difficult 
to precisely obtain a certain client load in these environments. 

The ICEfaces client is written in Java allowing the precise simulation of 
several important client-server interactions. It scales as well (in terms of 
clients) as JMeter, plus you can do what you want with the threads, allowing 
precise simulation of the blocking-updates+ping interaction making it an 
ideal passive client for server push environments. It does not have any gui 
configuration so the test writer is responsible for understanding the precise 
transaction, and being able to simulate it with code. There is a learning 
curve to overcome. 

General overview 
----------------

The test client is broken into the basic concepts of client and actor. 

The Client baseclass provides facilities for common actions, such as making an 
initial request of the application, easy methods for posting and retrieving 
the request responses, parsing and retaining the parsed information 
required for subsequent interaction with the application, such as JSessionID, ice.session, 
ice.view, etc. 

The Actor subclasses represent a single (or multiple) request to be made of 
the server. An example might be a ping request to http://server:port/app/block/ping
or http://server:port/app/block/receive-updates. The Actor is responsible for 
creating a String object containing the request parameters for a particular 
request when asked. So you can see that an AJAX request to press a button consists 
of formatting a String containing the request parameters that a browser would 
have submitted had a button been pressed. 


The Client makes use of Actors through ActionThreads. The Client subclass writer is free 
to create as many ActionThreads as he/she deems necessary to perform the Ajax interaction 
for a particular Client. For example, the standard client interaction with an asynchronous 
application consists of a thread involved in a blocking request to receive-updated-views 
and periodically a ping request is used to release the blocking connection, and is followed 
quickly by a receive-updates request. This requires two threads to accomplish without 
external help (a server push generating content for example) and that has been the 
approach taken in the StandalonePingReceiveUpdatesClient. One Actor simply returns 
the String representing a ping request (using the ice.session and ice.view parameters 
parsed from the initial request, and the other Actor subclass does the requests for 
the receive-updated-views, and once that response is returned, it carries on to receive-updates. 
This Actor also uses information parsed from the initial request and in this way can 
multiple threads represent one JSESSIONID. 

The range of activities that Actors can provide is limited only by the amount of 
code someone wants to write. However, the nature of the ICEfaces component protocols 
does make this a little bit unweildy at present. 

The ActionThread supports such concepts as initial request delays, inter request 
delays, and request repeat counts. This works particularly well for repetitive 
Actions, but is a bit unwieldy for streams of one-off operations. An example is 
logging into an application, navigating to a certain page, and doing various interactions. 


Another difficulty in generating UI based interaction such as button pressing or 
various component interaction is the complexity of the request required, and how best 
to generate this value. We have attempted to simplify the content creation process 
by creating Event objects, but this remains a work in process. An example of the code 
generated for a mouse click (for interaction with the timezone app) contains the following code: 

data.append(URLEncoder.encode("ice.submit.partial", "UTF-8")).append("=");
data.append(URLEncoder.encode(partialSubmit, "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.target", "UTF-8")).append("=");
data.append(URLEncoder.encode(componentId, "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.captured", "UTF-8")).append("=");
data.append(URLEncoder.encode(componentId, "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.type", "UTF-8")).append("=");
data.append(URLEncoder.encode(eventType, "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.alt", "UTF-8")).append("=");
data.append(URLEncoder.encode(Boolean.toString(altMod), "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.ctrl", "UTF-8")).append("=");
data.append(URLEncoder.encode(Boolean.toString(ctrlMod), "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.shift", "UTF-8")).append("=");
data.append(URLEncoder.encode(Boolean.toString(shiftMod), "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.meta", "UTF-8")).append("=");
data.append(URLEncoder.encode(Boolean.toString(metaMod), "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.x", "UTF-8")).append("=");
data.append(URLEncoder.encode(Integer.toString(p.x), "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.y", "UTF-8")).append("=");
data.append(URLEncoder.encode(Integer.toString(p.y), "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.left", "UTF-8")).append("=");
data.append(URLEncoder.encode(Boolean.toString(leftButton), "UTF-8")).append("&");

data.append(URLEncoder.encode("ice.event.right", "UTF-8")).append("=");
data.append(URLEncoder.encode(Boolean.toString(rightButton), "UTF-8"));



Interaction with various components appears to be rarely standard, and the exact 
number and nature of the request parameters is not documented, but requires a 
proxy to observe directly. 




Running the Java TestClient 
---------------------------

The java test client supports XML configuration of existing test utilities. A 
test is launched by running the test client, specifying a configuration file, 
and optionally overriding some of the configured parameters via the command line. 
This is useful for increasing client counts, for example, without rewriting the 
config file. 

The icefaces distribution comes in a jar file with a manifest facilitating 
simple operation. 


java -jar testClient.jar [URL] | [-f 'config file']
                                 [-c 'override ClientCount']
                                 [-u 'override URL'] 
                                 [-d 'override request delay']
                                 [-r 'override repeatCount']
                                 [-s 'interclient start delay']


The Main class is org.icesoft.testclient.TestClientLauncher 


The contents of the configuration file contains similar parameters: 

<testDefinition>

    <client>
        <clientClass>org.icesoft.testclient.client.TimezoneMultiViewClient</clientClass>
        <testURL>http://localhost:8080/timezone3</testURL> <!-- -u -->
        <clientCount>10</clientCount>                      <!-- -c --> 
        <initialDelay>3000</initialDelay>            
        <interRequestDelay>2000</interRequestDelay>        <!-- -d -->
        <repeatCount>300</repeatCount>                     <!-- -r -->
	<branch>false</branch>
    </client>

</testDefinition>


The <branch> element supports using the 1.6.2 protocol for icefaces parameters, 
but is otherwise unncessary. The command line also allows specification of the 
-s parameter allowing for copies of clients to be launched with a delay between 
them. Otherwise, the Client copies are launched as quickly as possible. 


Working through an example
---------------------------

Timezone is a relatively simple application, consisting of the ability to click on 
a map and select a timezone. For this application, I will use a standard ping + 
receive-updates pairing to read the updates. Whether or not I can use the existing 
Actor setup depends on what I want to do with the results of the test. When a 
user clicks on the page, the next update contains the timezone selected. If I don't 
care what the update contains, I can likely reuse the existing Actors. If I do care, 
for the purposes of functional tests, then I will need to write a custom Actor 
subclass to read the update (likely with a regex) and do something with it. 

The interesting part is going to be writing the Actor that submits the send-receive-updates 
request containing the parameters that would have come from a browser. 